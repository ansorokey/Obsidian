Collection user information is one of the most essential features of a web page, and that can be done through Flask as well.
In order to make form set up quick and simple, flask utilized the extensions (packages) *WTForms* and its wrapper, *Flask-WTF*

## Setting Up
Before getting started, be sure that a SECRET_KEY is established somewhere in the project. WTForms requires on to prevents [[Cross Site Request Forgery]]

After this is done, we can start installing and using flask-wtf.
`pipenv install Flask-WTF`

### Form Class
Just like how we created a class file for the Flask app configuration, so too will we create a class for a form in the same app home directory. Import flask-wtf to create a new form class that extends the package.
Along with the form class, we will be importing different types of form inputs and fields to make use of within the class.
```py
# The class
from flask_wtf import FlaskForm

# The inputs
from wtforms import StringField, SubmitField
```
*view additional field types [here](https://wtforms.readthedocs.io/en/2.3.x/fields/#basic-fields)*

Our form class will inherit the FlaskForm as a parent, and each input in the form will be a class variable, set to an invoked field with additional parameters passed in, such as a label name.
```py
class SampleForm(FlaskForm):
	# Variable name is how the field will be accessed
	# String passed to input will be the field's label
    name = StringField('Name')
    submit = SubmitField('Submit')
```

### Form Route
With the class complete, we can now create an instance of the form, and pass it in to a form template. In our app file, import the class definition for the form.
`from app.form.py import SampleForm`

Within a route definition, create a new instance of the form.
```py
@app.route('/form')
def sample_form():
	form = SampleForm()
```

The form is now a variable we can pass down to a template. This instance contains variables that are the inputs and labels of the form. Return a form template with the form passed in as a variable for Jinja
`return render_template('form.html', form=form)`

### Form Template
Lastly, we need the form template. Within the templates directory, create a new template for the form. The inputs will be accessed using the class variable names, called on the name of the form passed in.
Remember that a SECRET_KEY is required for form use, so a piece of csrf logic is added after the form definition.
In addition to csrf protection, we need to add a hidden tag in the beginning of the form. This will allow us to submit and let the flask seever know it is coming from thedocs original user and location, and not a cross-site scripting attack.
```py
<form> 
    {{ form.csrf_token }}
    {{ form.hidden_tag() }}
    <p>
	    # Renders the input's label
        {{ form.name.label }}
        # Renders the input (invoked)
        {{ form.name() }}
    </p>
</form>
```

When rendering the inputs, we can additional arguments to make modifications.
```py
form.name(size=32)
form.password(placeholder='Enter your password')
```

## Form Submission
With a form fully set up, we now need to be able to do something with the user entered values.
Recall that there are two different methods to use with a form: get and post.
- POST is the most common. Posting handles large data values and keeps information more private.
- GET is used much less, but can still be used. The form data is added to the URL, which can be saved as a bookmark. Useful for something like a search. This does mean that any information that should be private (passwords, security codes) are completely visible. And it cannot handle too much data, as the URL bar has a max character limit of 2,048.

### Route Methods
Flask routes are GET requests by default. We can change the request type by passing in a `methods` key to the argument list, with a list of the requests we want it to be able to handle.
```py
@app.route('/form', methods=['GET', 'POST'])
```

In order to send the user entered data up throigh flask, we need to specify the method of the html form. For now, with a post.
`<form method="POST">`

Now when the submit button is pressed, the form data is processed with the validators defined in its class. None were defined, so it is valid.
This validation can be checked on the route. Adding a conditional will allow us to see if the form data was submitted successfully. It will evaluate to either True or False.
```py
@app.route('/form', methods=['GET', 'POST'])
def form_page():
  form = SampleForm()
  if form.validate_on_submit()
    return 'Submission successful'
```
